var ALIASES = {};
ALIASES["adler32"] = {};
ALIASES["aho_corasick"] = {};
ALIASES["anyhow"] = {};
ALIASES["base64"] = {};
ALIASES["bit_vec"] = {};
ALIASES["bitflags"] = {};
ALIASES["byteorder"] = {};
ALIASES["bytes"] = {};
ALIASES["c2_chacha"] = {};
ALIASES["cfg_if"] = {};
ALIASES["chrono"] = {};
ALIASES["color_quant"] = {};
ALIASES["crc"] = {};
ALIASES["crc32fast"] = {};
ALIASES["ctor"] = {};
ALIASES["deflate"] = {};
ALIASES["either"] = {};
ALIASES["env_logger"] = {};
ALIASES["fnv"] = {};
ALIASES["gbdt"] = {};
ALIASES["generic_array"] = {};
ALIASES["getrandom"] = {};
ALIASES["ghost"] = {};
ALIASES["gif"] = {};
ALIASES["hashbrown"] = {};
ALIASES["hashbrown_tstd"] = {};
ALIASES["hex"] = {};
ALIASES["http"] = {};
ALIASES["httparse"] = {};
ALIASES["humantime"] = {};
ALIASES["idna"] = {};
ALIASES["image"] = {};
ALIASES["inflate"] = {};
ALIASES["integer_encoding"] = {};
ALIASES["inventory"] = {};
ALIASES["inventory_impl"] = {};
ALIASES["itertools"] = {};
ALIASES["itoa"] = {};
ALIASES["jpeg_decoder"] = {};
ALIASES["jsonwebtoken"] = {};
ALIASES["lazy_static"] = {};
ALIASES["libc"] = {};
ALIASES["log"] = {};
ALIASES["lzw"] = {};
ALIASES["matches"] = {};
ALIASES["matrixmultiply"] = {};
ALIASES["memchr"] = {};
ALIASES["miniz_oxide"] = {};
ALIASES["num"] = {};
ALIASES["num_bigint"] = {};
ALIASES["num_complex"] = {};
ALIASES["num_integer"] = {};
ALIASES["num_iter"] = {};
ALIASES["num_rational"] = {};
ALIASES["num_traits"] = {};
ALIASES["percent_encoding"] = {};
ALIASES["png"] = {};
ALIASES["ppv_lite86"] = {};
ALIASES["proc_macro2"] = {};
ALIASES["prost"] = {};
ALIASES["prost_derive"] = {};
ALIASES["protected_fs"] = {};
ALIASES["quick_error"] = {};
ALIASES["quote"] = {};
ALIASES["rand"] = {};
ALIASES["rand_chacha"] = {};
ALIASES["rand_core"] = {};
ALIASES["rawpointer"] = {};
ALIASES["rdrand"] = {};
ALIASES["regex"] = {};
ALIASES["regex_syntax"] = {};
ALIASES["ring"] = {};
ALIASES["rulinalg"] = {};
ALIASES["rustface"] = {};
ALIASES["rustls"] = {};
ALIASES["rusty_leveldb"] = {};
ALIASES["rusty_machine"] = {};
ALIASES["ryu"] = {};
ALIASES["sct"] = {};
ALIASES["serde"] = {};
ALIASES["serde_derive"] = {};
ALIASES["serde_json"] = {};
ALIASES["sgx_alloc"] = {};
ALIASES["sgx_backtrace_sys"] = {};
ALIASES["sgx_demangle"] = {};
ALIASES["sgx_libc"] = {};
ALIASES["sgx_rand"] = {};
ALIASES["sgx_tcrypto"] = {};
ALIASES["sgx_tprotected_fs"] = {};
ALIASES["sgx_trts"] = {};
ALIASES["sgx_tse"] = {};
ALIASES["sgx_tstd"] = {"<<=":[{'crate':'sgx_tstd','ty':8,'name':'ShlAssign','desc':'The left shift assignment operator `<<=`.','p':'sgx_tstd::ops'}],"]":[{'crate':'sgx_tstd','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in…','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in…','p':'sgx_tstd::ops'}],"?":[{'crate':'sgx_tstd','ty':8,'name':'Try','desc':'A trait for customizing the behavior of the `?` operator.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':14,'name':'try','desc':'Unwraps a result or propagates its error.','p':'sgx_tstd'}],"*":[{'crate':'sgx_tstd','ty':8,'name':'Mul','desc':'The multiplication operator `*`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'DerefMut','desc':'Used for mutable dereferencing operations, like in `*v =…','p':'sgx_tstd::ops'}],">=":[{'crate':'sgx_tstd','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'sgx_tstd::cmp'},{'crate':'sgx_tstd','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'sgx_tstd::cmp'}],"..=":[{'crate':'sgx_tstd','ty':3,'name':'RangeInclusive','desc':'A range bounded inclusively below and above (`start..=end`).','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':3,'name':'RangeToInclusive','desc':'A range only bounded inclusively above (`..=end`).','p':'sgx_tstd::ops'}],"^=":[{'crate':'sgx_tstd','ty':8,'name':'BitXorAssign','desc':'The bitwise XOR assignment operator `^=`.','p':'sgx_tstd::ops'}],">":[{'crate':'sgx_tstd','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'sgx_tstd::cmp'},{'crate':'sgx_tstd','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'sgx_tstd::cmp'}],"<=":[{'crate':'sgx_tstd','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'sgx_tstd::cmp'},{'crate':'sgx_tstd','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'sgx_tstd::cmp'}],"^":[{'crate':'sgx_tstd','ty':8,'name':'BitXor','desc':'The bitwise XOR operator `^`.','p':'sgx_tstd::ops'}],"&=":[{'crate':'sgx_tstd','ty':8,'name':'BitAndAssign','desc':'The bitwise AND assignment operator `&=`.','p':'sgx_tstd::ops'}],"[]":[{'crate':'sgx_tstd','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in…','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in…','p':'sgx_tstd::ops'}],"+":[{'crate':'sgx_tstd','ty':8,'name':'Add','desc':'The addition operator `+`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'sgx_tstd::ops'}],"%":[{'crate':'sgx_tstd','ty':8,'name':'Rem','desc':'The remainder operator `%`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'sgx_tstd::ops'}],">>=":[{'crate':'sgx_tstd','ty':8,'name':'ShrAssign','desc':'The right shift assignment operator `>>=`.','p':'sgx_tstd::ops'}],"/":[{'crate':'sgx_tstd','ty':8,'name':'Div','desc':'The division operator `/`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'sgx_tstd::ops'}],"[":[{'crate':'sgx_tstd','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in…','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in…','p':'sgx_tstd::ops'}],"..":[{'crate':'sgx_tstd','ty':3,'name':'Range','desc':'A (half-open) range bounded inclusively below and…','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':3,'name':'RangeFrom','desc':'A range only bounded inclusively below (`start..`).','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':3,'name':'RangeFull','desc':'An unbounded range (`..`).','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':3,'name':'RangeTo','desc':'A range only bounded exclusively above (`..end`).','p':'sgx_tstd::ops'}],"<<":[{'crate':'sgx_tstd','ty':8,'name':'Shl','desc':'The left shift operator `<<`. Note that because this trait…','p':'sgx_tstd::ops'}],"{}":[{'crate':'sgx_tstd','ty':8,'name':'Display','desc':'Format trait for an empty format, `{}`.','p':'sgx_tstd::fmt'}],"<":[{'crate':'sgx_tstd','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'sgx_tstd::cmp'},{'crate':'sgx_tstd','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'sgx_tstd::cmp'}],"*=":[{'crate':'sgx_tstd','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'sgx_tstd::ops'}],"&":[{'crate':'sgx_tstd','ty':8,'name':'BitAnd','desc':'The bitwise AND operator `&`.','p':'sgx_tstd::ops'}],"|=":[{'crate':'sgx_tstd','ty':8,'name':'BitOrAssign','desc':'The bitwise OR assignment operator `|=`.','p':'sgx_tstd::ops'}],"|":[{'crate':'sgx_tstd','ty':8,'name':'BitOr','desc':'The bitwise OR operator `|`.','p':'sgx_tstd::ops'}],"&*":[{'crate':'sgx_tstd','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'sgx_tstd::ops'}],">>":[{'crate':'sgx_tstd','ty':8,'name':'Shr','desc':'The right shift operator `>>`. Note that because this…','p':'sgx_tstd::ops'}],"-=":[{'crate':'sgx_tstd','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'sgx_tstd::ops'}],"==":[{'crate':'sgx_tstd','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'sgx_tstd::cmp'},{'crate':'sgx_tstd','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'sgx_tstd::cmp'}],"!=":[{'crate':'sgx_tstd','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'sgx_tstd::cmp'},{'crate':'sgx_tstd','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'sgx_tstd::cmp'}],"memcpy":[{'crate':'sgx_tstd','ty':5,'name':'copy_nonoverlapping','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'sgx_tstd::intrinsics'},{'crate':'sgx_tstd','ty':5,'name':'copy_nonoverlapping','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'sgx_tstd::ptr'}],"memmove":[{'crate':'sgx_tstd','ty':5,'name':'copy','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'sgx_tstd::intrinsics'},{'crate':'sgx_tstd','ty':5,'name':'copy','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'sgx_tstd::ptr'}],"{:?}":[{'crate':'sgx_tstd','ty':8,'name':'Debug','desc':'`?` formatting.','p':'sgx_tstd::fmt'}],"-":[{'crate':'sgx_tstd','ty':8,'name':'Neg','desc':'The unary negation operator `-`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'Sub','desc':'The subtraction operator `-`.','p':'sgx_tstd::ops'},{'crate':'sgx_tstd','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'sgx_tstd::ops'}],"+=":[{'crate':'sgx_tstd','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'sgx_tstd::ops'}],"/=":[{'crate':'sgx_tstd','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'sgx_tstd::ops'}],"%=":[{'crate':'sgx_tstd','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'sgx_tstd::ops'}],};
ALIASES["sgx_types"] = {};
ALIASES["sgx_unwind"] = {};
ALIASES["smallvec"] = {};
ALIASES["snap"] = {};
ALIASES["spin"] = {};
ALIASES["stream_cipher"] = {};
ALIASES["syn"] = {};
ALIASES["teaclave_access_control_service_enclave"] = {};
ALIASES["teaclave_attestation"] = {};
ALIASES["teaclave_authentication_service_enclave"] = {};
ALIASES["teaclave_binder"] = {};
ALIASES["teaclave_binder_attribute"] = {};
ALIASES["teaclave_config"] = {};
ALIASES["teaclave_crypto"] = {};
ALIASES["teaclave_execution_service_enclave"] = {};
ALIASES["teaclave_executor"] = {};
ALIASES["teaclave_frontend_service_enclave"] = {};
ALIASES["teaclave_function"] = {};
ALIASES["teaclave_functional_tests_enclave"] = {};
ALIASES["teaclave_integration_tests_enclave"] = {};
ALIASES["teaclave_management_service_enclave"] = {};
ALIASES["teaclave_proto"] = {};
ALIASES["teaclave_rpc"] = {};
ALIASES["teaclave_rpc_proc_macro"] = {};
ALIASES["teaclave_runtime"] = {};
ALIASES["teaclave_scheduler_service_enclave"] = {};
ALIASES["teaclave_service_enclave_utils"] = {};
ALIASES["teaclave_service_enclave_utils_proc_macro"] = {};
ALIASES["teaclave_sgx_tool_enclave"] = {};
ALIASES["teaclave_storage_service_enclave"] = {};
ALIASES["teaclave_test_utils"] = {};
ALIASES["teaclave_test_utils_proc_macro"] = {};
ALIASES["teaclave_types"] = {};
ALIASES["teaclave_unit_tests_enclave"] = {};
ALIASES["teaclave_worker"] = {};
ALIASES["termcolor"] = {};
ALIASES["thiserror"] = {};
ALIASES["thiserror_impl"] = {};
ALIASES["thread_local"] = {};
ALIASES["threadpool"] = {};
ALIASES["tiff"] = {};
ALIASES["toml"] = {};
ALIASES["typenum"] = {};
ALIASES["unicode_bidi"] = {};
ALIASES["unicode_normalization"] = {};
ALIASES["unicode_xid"] = {};
ALIASES["untrusted"] = {};
ALIASES["url"] = {};
ALIASES["uuid"] = {};
ALIASES["webpki"] = {};
ALIASES["webpki_roots"] = {};
ALIASES["yasna"] = {};
