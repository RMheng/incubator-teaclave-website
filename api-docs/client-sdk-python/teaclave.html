<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>teaclave API documentation</title>
<meta name="description" content="Python package `teaclave` is the client SDK for Python developers, providing
some essential data structures, service, and client classes to establish
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>teaclave</code></h1>
</header>
<section id="section-intro">
<p>Python package <code><a title="teaclave" href="#teaclave">teaclave</a></code> is the client SDK for Python developers, providing
some essential data structures, service, and client classes to establish
trusted TLS channel and communicate with Teaclave services (e.g., the
authentication service and frontend service) through RPC protocols.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# &#34;License&#34;); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
&#34;&#34;&#34;
Python package `teaclave` is the client SDK for Python developers, providing
some essential data structures, service, and client classes to establish
trusted TLS channel and communicate with Teaclave services (e.g., the
authentication service and frontend service) through RPC protocols.
&#34;&#34;&#34;

import struct
import json
import base64
import toml
import os
import time
import ssl
import socket

from typing import Tuple, Dict, List, Any

from cryptography import x509
from cryptography.hazmat.backends import default_backend

from OpenSSL.crypto import load_certificate, FILETYPE_PEM, FILETYPE_ASN1
from OpenSSL.crypto import X509Store, X509StoreContext
from OpenSSL import crypto

__all__ = [
    &#39;FrontendClient&#39;, &#39;FrontendService&#39;, &#39;AuthenticationClient&#39;,
    &#39;AuthenticationService&#39;, &#39;FunctionInput&#39;, &#39;FunctionOutput&#39;, &#39;OwnerList&#39;,
    &#39;DataMap&#39;
]

Metadata = Dict[str, str]


class FunctionInput:
    &#34;&#34;&#34;Function input for registering.

    Args:
        name: Name of input data.
        description: Description of the input data.
    &#34;&#34;&#34;
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description


class FunctionOutput:
    &#34;&#34;&#34;Function output for registering.

    Args:
        name: Name of output data.
        description: Description of the output data.
    &#34;&#34;&#34;
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description


class OwnerList:
    &#34;&#34;&#34;Defines data ownership.

    Args:
        data_name: Name of output data.
        uids: A list of user id which own this data.
    &#34;&#34;&#34;
    def __init__(self, data_name: str, uids: List[str]):
        self.data_name = data_name
        self.uids = uids


class DataMap:
    &#34;&#34;&#34;Assign data id to input or output data.

    Args:
        data_name: Name of output data.
        data_id: Id for the data name.
    &#34;&#34;&#34;
    def __init__(self, data_name, data_id):
        self.data_name = data_name
        self.data_id = data_id


class CryptoInfo:
    &#34;&#34;&#34;Cryptographic information for the input/output data.

    Args:
        schema: Encryption algorithms for the input/output data.
        key: Key for encryption and decryption, bytes in list.
        iv: IV, bytes in list.
    &#34;&#34;&#34;
    def __init__(self, schema: str, key: List[int], iv: List[int]):
        self.schema = schema
        self.key = key
        self.iv = iv


class UserRegisterReqeust:
    def __init__(self, user_id: str, user_password: str):
        self.request = &#34;user_register&#34;
        self.id = user_id
        self.password = user_password


class UserLoginRequest:
    def __init__(self, user_id: str, user_password: str):
        self.request = &#34;user_login&#34;
        self.id = user_id
        self.password = user_password


class AuthenticationService:
    &#34;&#34;&#34;
    Establish trusted channel with the authentication service and provide
    clients to send request through RPC.

    Args:
        address: The address of the remote services in tuple.
        as_root_ca_cert_path: Root CA certification of the attestation services
            to verify the attestation report.
        enclave_info_path: Path of enclave info to verify the remote service in
            the attestation report.
    &#34;&#34;&#34;
    _context = ssl._create_unverified_context()
    _channel = None

    def __init__(self, address: Tuple[str, int], as_root_ca_cert_path: str,
                 enclave_info_path: str):
        self.address = address
        self.as_root_ca_cert_path = as_root_ca_cert_path
        self.enclave_info_path = enclave_info_path

    def connect(self):
        &#34;&#34;&#34;Establish trusted connection and verify remote attestation report.

        Returns:
            AuthenticationService: The original object which can be chained
                with other methods.
        &#34;&#34;&#34;
        sock = socket.create_connection(self.address)
        channel = self._context.wrap_socket(sock,
                                            server_hostname=self.address[0])
        cert = channel.getpeercert(binary_form=True)
        _verify_report(self.as_root_ca_cert_path, self.enclave_info_path, cert,
                       &#34;authentication&#34;)

        self._channel = channel

        return self

    def get_client(self):
        &#34;&#34;&#34;Get a client of authentication service to send RPC requests.

        Returns:
            AuthenticationClient: Used for send/receive RPC requests.
        &#34;&#34;&#34;
        return AuthenticationClient(self._channel)


class AuthenticationClient:
    &#34;&#34;&#34;Client to communicate with the authentication service.

    Args:
        channel: Trusted TLS socket (verified with remote attestation).
    &#34;&#34;&#34;
    def __init__(self, channel: ssl.SSLSocket):
        self.channel = channel

    def user_register(self, user_id: str, user_password: str):
        &#34;&#34;&#34;Register a new user.

        Args:
            user_id: User ID.
            user_password: Password.
        &#34;&#34;&#34;
        request = UserRegisterReqeust(user_id, user_password)
        _write_message(self.channel, request)
        _ = _read_message(self.channel)

    def user_login(self, user_id: str, user_password: str) -&gt; str:
        &#34;&#34;&#34;Login and get a session token.

        Args:
            user_id: User ID.
            user_password: Password.

        Returns:
            str: User login token.
        &#34;&#34;&#34;
        request = UserLoginRequest(user_id, user_password)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;token&#34;]


class FrontendService:
    &#34;&#34;&#34;Establish trusted channel with the frontend service and provide
    clients to send request through RPC.

    Args:
        address: The address of the remote services in tuple.
        as_root_ca_cert_path: Root CA certification of the attestation services
            to verify the attestation report.
        enclave_info_path: Path of enclave info to verify the remote service in
            the attestation report.
    &#34;&#34;&#34;
    _context = ssl._create_unverified_context()
    _channel = None

    def __init__(self, address: Tuple[str, int], as_root_ca_cert_path: str,
                 enclave_info_path: str):
        self.address = address
        self.as_root_ca_cert_path = as_root_ca_cert_path
        self.enclave_info_path = enclave_info_path

    def connect(self):
        &#34;&#34;&#34;Establish trusted connection and verify remote attestation report.

        Returns:
            FrontendService: The original object which can be chained
                with other methods.
        &#34;&#34;&#34;
        sock = socket.create_connection(self.address)
        channel = self._context.wrap_socket(sock,
                                            server_hostname=self.address[0])
        cert = channel.getpeercert(binary_form=True)
        _verify_report(self.as_root_ca_cert_path, self.enclave_info_path, cert,
                       &#34;frontend&#34;)

        self._channel = channel
        return self

    def get_client(self):
        &#34;&#34;&#34;Get a client of frontend service to send RPC requests.

        Returns:
            FrontendClient: Used for send/receive RPC requests.
        &#34;&#34;&#34;
        return FrontendClient(self._channel)


class RegisterFunctionRequest:
    def __init__(self, metadata: Metadata, name: str, description: str,
                 executor_type: str, public: bool, payload: List[int],
                 arguments: List[str], inputs: List[FunctionInput],
                 outputs: List[FunctionOutput]):
        self.request = &#34;register_function&#34;
        self.metadata = metadata
        self.name = name
        self.description = description
        self.executor_type = executor_type
        self.public = public
        self.payload = payload
        self.arguments = arguments
        self.inputs = inputs
        self.outputs = outputs


class RegisterInputFileRequest:
    def __init__(self, metadata: Metadata, url: str, cmac: str,
                 crypto_info: CryptoInfo):
        self.request = &#34;register_input_file&#34;
        self.metadata = metadata
        self.url = url
        self.cmac = cmac
        self.crypto_info = crypto_info


class RegisterOutputFileRequest:
    def __init__(self, metadata: Metadata, url: str, crypto_info: CryptoInfo):
        self.request = &#34;register_output_file&#34;
        self.metadata = metadata
        self.url = url
        self.crypto_info = crypto_info


class UpdateInputFileRequest:
    def __init__(self, metadata: Metadata, data_id: str, url: str):
        self.request = &#34;update_input_file&#34;
        self.metadata = metadata
        self.data_id = data_id
        self.url = url


class UpdateOutputFileRequest:
    def __init__(self, metadata: Metadata, data_id: str, url: str):
        self.request = &#34;update_output_file&#34;
        self.metadata = metadata
        self.data_id = data_id
        self.url = url


class CreateTaskRequest:
    def __init__(self, metadata: Metadata, function_id: str,
                 function_arguments: Dict[str, Any], executor: str,
                 inputs_ownership: List[OwnerList],
                 outputs_ownership: List[OwnerList]):
        self.request = &#34;create_task&#34;
        self.metadata = metadata
        self.function_id = function_id
        self.function_arguments = function_arguments
        self.executor = executor
        self.inputs_ownership = inputs_ownership
        self.outputs_ownership = outputs_ownership


class AssignDataRequest:
    def __init__(self, metadata: Metadata, task_id: str, inputs: List[DataMap],
                 outputs: List[DataMap]):
        self.request = &#34;assign_data&#34;
        self.metadata = metadata
        self.task_id = task_id
        self.inputs = inputs
        self.outputs = outputs


class ApproveTaskRequest:
    def __init__(self, metadata: Metadata, task_id: str):
        self.request = &#34;approve_task&#34;
        self.metadata = metadata
        self.task_id = task_id


class InvokeTaskRequest:
    def __init__(self, metadata: Metadata, task_id: str):
        self.request = &#34;invoke_task&#34;
        self.metadata = metadata
        self.task_id = task_id


class GetTaskRequest:
    def __init__(self, metadata: Metadata, task_id: str):
        self.request = &#34;get_task&#34;
        self.metadata = metadata
        self.task_id = task_id


class FrontendClient:
    def __init__(self, channel: ssl.SSLSocket, metadata: Metadata = None):
        self.channel = channel
        self.metadata = metadata

    def register_function(self,
                          name: str,
                          description: str,
                          executor_type: str,
                          public: bool = True,
                          payload: List[int] = [],
                          arguments: List[str] = [],
                          inputs: List[FunctionInput] = [],
                          outputs: List[FunctionOutput] = []):
        request = RegisterFunctionRequest(self.metadata, name, description,
                                          executor_type, public, payload,
                                          arguments, inputs, outputs)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;function_id&#34;]

    def register_input_file(self, url: str, schema: str, key: List[int],
                            iv: List[int], cmac: str):
        request = RegisterInputFileRequest(self.metadata, url, cmac,
                                           CryptoInfo(schema, key, iv))
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;data_id&#34;]

    def register_output_file(self, url: str, schema: str, key: List[int],
                             iv: List[int]):
        request = RegisterOutputFileRequest(self.metadata, url,
                                            CryptoInfo(schema, key, iv))
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;data_id&#34;]

    def create_task(self,
                    function_id: str,
                    function_arguments: Dict[str, Any],
                    executor: str,
                    inputs_ownership: List[OwnerList] = [],
                    outputs_ownership: List[OwnerList] = []):
        function_arguments = json.dumps(function_arguments)
        request = CreateTaskRequest(self.metadata, function_id,
                                    function_arguments, executor,
                                    inputs_ownership, outputs_ownership)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;task_id&#34;]

    def assign_data_to_task(self, task_id: str, inputs: List[DataMap],
                            outputs: List[DataMap]):
        request = AssignDataRequest(self.metadata, task_id, inputs, outputs)
        _write_message(self.channel, request)
        _ = _read_message(self.channel)
        return

    def approve_task(self, task_id: str):
        request = ApproveTaskRequest(self.metadata, task_id)
        _write_message(self.channel, request)
        _ = _read_message(self.channel)
        return

    def invoke_task(self, task_id: str):
        request = InvokeTaskRequest(self.metadata, task_id)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        assert (response[&#34;result&#34;] == &#34;ok&#34;)

    def get_task_result(self, task_id: str):
        request = GetTaskRequest(self.metadata, task_id)

        while True:
            _write_message(self.channel, request)
            response = _read_message(self.channel)
            time.sleep(1)
            if response[&#34;content&#34;][&#34;status&#34;] == 10:
                break

        return response[&#34;content&#34;][&#34;result&#34;][&#34;result&#34;][&#34;Ok&#34;][&#34;return_value&#34;]

    def get_output_cmac_by_tag(self, task_id: str, tag: str):
        request = GetTaskRequest(self.metadata, task_id)
        while True:
            _write_message(self.channel, request)
            response = _read_message(self.channel)
            time.sleep(1)
            if response[&#34;content&#34;][&#34;status&#34;] == 10:
                break
        return response[&#34;content&#34;][&#34;result&#34;][&#34;result&#34;][&#34;Ok&#34;][&#34;tags_map&#34;][tag]


def _write_message(sock: ssl.SSLSocket, message: Any):
    class RequestEncoder(json.JSONEncoder):
        def default(self, o):
            return o.__dict__

    message = json.dumps(message, cls=RequestEncoder).encode()
    sock.sendall(struct.pack(&#34;&gt;Q&#34;, len(message)))
    sock.sendall(message)


def _read_message(sock: ssl.SSLSocket):
    response_len = struct.unpack(&#34;&gt;Q&#34;, sock.read(8))
    raw = bytearray()
    total_recv = 0
    while total_recv &lt; response_len[0]:
        data = sock.recv()
        total_recv += len(data)
        raw += data
    response = json.loads(raw)
    return response


def _verify_report(as_root_ca_cert_path: str, enclave_info_path: str,
                   cert: Dict[str, Any], endpoint_name: str):
    if os.environ.get(&#39;SGX_MODE&#39;) == &#39;SW&#39;:
        return

    cert = x509.load_der_x509_certificate(cert, default_backend())
    ext = json.loads(cert.extensions[0].value.value)

    report = bytes(ext[&#34;report&#34;])
    signature = bytes(ext[&#34;signature&#34;])
    signing_cert = bytes(ext[&#34;signing_cert&#34;])
    signing_cert = load_certificate(FILETYPE_ASN1, signing_cert)

    # verify signing cert with AS root cert
    with open(as_root_ca_cert_path) as f:
        as_root_ca_cert = f.read()
    as_root_ca_cert = load_certificate(FILETYPE_PEM, as_root_ca_cert)
    store = X509Store()
    store.add_cert(as_root_ca_cert)
    store.add_cert(signing_cert)
    store_ctx = X509StoreContext(store, as_root_ca_cert)
    store_ctx.verify_certificate()

    # verify report&#39;s signature
    crypto.verify(signing_cert, signature, bytes(ext[&#34;report&#34;]), &#39;sha256&#39;)

    report = json.loads(report)
    quote = report[&#39;isvEnclaveQuoteBody&#39;]
    quote = base64.b64decode(quote)

    # get mr_enclave and mr_signer from the quote
    mr_enclave = quote[112:112 + 32].hex()
    mr_signer = quote[176:176 + 32].hex()

    # get enclave_info
    enclave_info = toml.load(enclave_info_path)

    # verify mr_enclave and mr_signer
    enclave_name = &#34;teaclave_&#34; + endpoint_name + &#34;_service&#34;
    if mr_enclave != enclave_info[enclave_name][&#34;mr_enclave&#34;]:
        raise Exception(&#34;mr_enclave error&#34;)

    if mr_signer != enclave_info[enclave_name][&#34;mr_signer&#34;]:
        raise Exception(&#34;mr_signer error&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="teaclave.AuthenticationClient"><code class="flex name class">
<span>class <span class="ident">AuthenticationClient</span></span>
<span>(</span><span>channel: ssl.SSLSocket)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to communicate with the authentication service.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong></dt>
<dd>Trusted TLS socket (verified with remote attestation).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthenticationClient:
    &#34;&#34;&#34;Client to communicate with the authentication service.

    Args:
        channel: Trusted TLS socket (verified with remote attestation).
    &#34;&#34;&#34;
    def __init__(self, channel: ssl.SSLSocket):
        self.channel = channel

    def user_register(self, user_id: str, user_password: str):
        &#34;&#34;&#34;Register a new user.

        Args:
            user_id: User ID.
            user_password: Password.
        &#34;&#34;&#34;
        request = UserRegisterReqeust(user_id, user_password)
        _write_message(self.channel, request)
        _ = _read_message(self.channel)

    def user_login(self, user_id: str, user_password: str) -&gt; str:
        &#34;&#34;&#34;Login and get a session token.

        Args:
            user_id: User ID.
            user_password: Password.

        Returns:
            str: User login token.
        &#34;&#34;&#34;
        request = UserLoginRequest(user_id, user_password)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;token&#34;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="teaclave.AuthenticationClient.user_login"><code class="name flex">
<span>def <span class="ident">user_login</span></span>(<span>self, user_id: str, user_password: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Login and get a session token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong></dt>
<dd>User ID.</dd>
<dt><strong><code>user_password</code></strong></dt>
<dd>Password.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>User login token.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_login(self, user_id: str, user_password: str) -&gt; str:
    &#34;&#34;&#34;Login and get a session token.

    Args:
        user_id: User ID.
        user_password: Password.

    Returns:
        str: User login token.
    &#34;&#34;&#34;
    request = UserLoginRequest(user_id, user_password)
    _write_message(self.channel, request)
    response = _read_message(self.channel)
    return response[&#34;content&#34;][&#34;token&#34;]</code></pre>
</details>
</dd>
<dt id="teaclave.AuthenticationClient.user_register"><code class="name flex">
<span>def <span class="ident">user_register</span></span>(<span>self, user_id: str, user_password: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong></dt>
<dd>User ID.</dd>
<dt><strong><code>user_password</code></strong></dt>
<dd>Password.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_register(self, user_id: str, user_password: str):
    &#34;&#34;&#34;Register a new user.

    Args:
        user_id: User ID.
        user_password: Password.
    &#34;&#34;&#34;
    request = UserRegisterReqeust(user_id, user_password)
    _write_message(self.channel, request)
    _ = _read_message(self.channel)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="teaclave.AuthenticationService"><code class="flex name class">
<span>class <span class="ident">AuthenticationService</span></span>
<span>(</span><span>address: Tuple[str, int], as_root_ca_cert_path: str, enclave_info_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish trusted channel with the authentication service and provide
clients to send request through RPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>The address of the remote services in tuple.</dd>
<dt><strong><code>as_root_ca_cert_path</code></strong></dt>
<dd>Root CA certification of the attestation services
to verify the attestation report.</dd>
<dt><strong><code>enclave_info_path</code></strong></dt>
<dd>Path of enclave info to verify the remote service in
the attestation report.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthenticationService:
    &#34;&#34;&#34;
    Establish trusted channel with the authentication service and provide
    clients to send request through RPC.

    Args:
        address: The address of the remote services in tuple.
        as_root_ca_cert_path: Root CA certification of the attestation services
            to verify the attestation report.
        enclave_info_path: Path of enclave info to verify the remote service in
            the attestation report.
    &#34;&#34;&#34;
    _context = ssl._create_unverified_context()
    _channel = None

    def __init__(self, address: Tuple[str, int], as_root_ca_cert_path: str,
                 enclave_info_path: str):
        self.address = address
        self.as_root_ca_cert_path = as_root_ca_cert_path
        self.enclave_info_path = enclave_info_path

    def connect(self):
        &#34;&#34;&#34;Establish trusted connection and verify remote attestation report.

        Returns:
            AuthenticationService: The original object which can be chained
                with other methods.
        &#34;&#34;&#34;
        sock = socket.create_connection(self.address)
        channel = self._context.wrap_socket(sock,
                                            server_hostname=self.address[0])
        cert = channel.getpeercert(binary_form=True)
        _verify_report(self.as_root_ca_cert_path, self.enclave_info_path, cert,
                       &#34;authentication&#34;)

        self._channel = channel

        return self

    def get_client(self):
        &#34;&#34;&#34;Get a client of authentication service to send RPC requests.

        Returns:
            AuthenticationClient: Used for send/receive RPC requests.
        &#34;&#34;&#34;
        return AuthenticationClient(self._channel)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="teaclave.AuthenticationService.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish trusted connection and verify remote attestation report.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="teaclave.AuthenticationService" href="#teaclave.AuthenticationService">AuthenticationService</a></code></dt>
<dd>The original object which can be chained
with other methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;Establish trusted connection and verify remote attestation report.

    Returns:
        AuthenticationService: The original object which can be chained
            with other methods.
    &#34;&#34;&#34;
    sock = socket.create_connection(self.address)
    channel = self._context.wrap_socket(sock,
                                        server_hostname=self.address[0])
    cert = channel.getpeercert(binary_form=True)
    _verify_report(self.as_root_ca_cert_path, self.enclave_info_path, cert,
                   &#34;authentication&#34;)

    self._channel = channel

    return self</code></pre>
</details>
</dd>
<dt id="teaclave.AuthenticationService.get_client"><code class="name flex">
<span>def <span class="ident">get_client</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a client of authentication service to send RPC requests.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="teaclave.AuthenticationClient" href="#teaclave.AuthenticationClient">AuthenticationClient</a></code></dt>
<dd>Used for send/receive RPC requests.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_client(self):
    &#34;&#34;&#34;Get a client of authentication service to send RPC requests.

    Returns:
        AuthenticationClient: Used for send/receive RPC requests.
    &#34;&#34;&#34;
    return AuthenticationClient(self._channel)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="teaclave.DataMap"><code class="flex name class">
<span>class <span class="ident">DataMap</span></span>
<span>(</span><span>data_name, data_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign data id to input or output data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_name</code></strong></dt>
<dd>Name of output data.</dd>
<dt><strong><code>data_id</code></strong></dt>
<dd>Id for the data name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataMap:
    &#34;&#34;&#34;Assign data id to input or output data.

    Args:
        data_name: Name of output data.
        data_id: Id for the data name.
    &#34;&#34;&#34;
    def __init__(self, data_name, data_id):
        self.data_name = data_name
        self.data_id = data_id</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient"><code class="flex name class">
<span>class <span class="ident">FrontendClient</span></span>
<span>(</span><span>channel: ssl.SSLSocket, metadata: Dict[str, str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrontendClient:
    def __init__(self, channel: ssl.SSLSocket, metadata: Metadata = None):
        self.channel = channel
        self.metadata = metadata

    def register_function(self,
                          name: str,
                          description: str,
                          executor_type: str,
                          public: bool = True,
                          payload: List[int] = [],
                          arguments: List[str] = [],
                          inputs: List[FunctionInput] = [],
                          outputs: List[FunctionOutput] = []):
        request = RegisterFunctionRequest(self.metadata, name, description,
                                          executor_type, public, payload,
                                          arguments, inputs, outputs)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;function_id&#34;]

    def register_input_file(self, url: str, schema: str, key: List[int],
                            iv: List[int], cmac: str):
        request = RegisterInputFileRequest(self.metadata, url, cmac,
                                           CryptoInfo(schema, key, iv))
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;data_id&#34;]

    def register_output_file(self, url: str, schema: str, key: List[int],
                             iv: List[int]):
        request = RegisterOutputFileRequest(self.metadata, url,
                                            CryptoInfo(schema, key, iv))
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;data_id&#34;]

    def create_task(self,
                    function_id: str,
                    function_arguments: Dict[str, Any],
                    executor: str,
                    inputs_ownership: List[OwnerList] = [],
                    outputs_ownership: List[OwnerList] = []):
        function_arguments = json.dumps(function_arguments)
        request = CreateTaskRequest(self.metadata, function_id,
                                    function_arguments, executor,
                                    inputs_ownership, outputs_ownership)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        return response[&#34;content&#34;][&#34;task_id&#34;]

    def assign_data_to_task(self, task_id: str, inputs: List[DataMap],
                            outputs: List[DataMap]):
        request = AssignDataRequest(self.metadata, task_id, inputs, outputs)
        _write_message(self.channel, request)
        _ = _read_message(self.channel)
        return

    def approve_task(self, task_id: str):
        request = ApproveTaskRequest(self.metadata, task_id)
        _write_message(self.channel, request)
        _ = _read_message(self.channel)
        return

    def invoke_task(self, task_id: str):
        request = InvokeTaskRequest(self.metadata, task_id)
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        assert (response[&#34;result&#34;] == &#34;ok&#34;)

    def get_task_result(self, task_id: str):
        request = GetTaskRequest(self.metadata, task_id)

        while True:
            _write_message(self.channel, request)
            response = _read_message(self.channel)
            time.sleep(1)
            if response[&#34;content&#34;][&#34;status&#34;] == 10:
                break

        return response[&#34;content&#34;][&#34;result&#34;][&#34;result&#34;][&#34;Ok&#34;][&#34;return_value&#34;]

    def get_output_cmac_by_tag(self, task_id: str, tag: str):
        request = GetTaskRequest(self.metadata, task_id)
        while True:
            _write_message(self.channel, request)
            response = _read_message(self.channel)
            time.sleep(1)
            if response[&#34;content&#34;][&#34;status&#34;] == 10:
                break
        return response[&#34;content&#34;][&#34;result&#34;][&#34;result&#34;][&#34;Ok&#34;][&#34;tags_map&#34;][tag]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="teaclave.FrontendClient.approve_task"><code class="name flex">
<span>def <span class="ident">approve_task</span></span>(<span>self, task_id: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approve_task(self, task_id: str):
    request = ApproveTaskRequest(self.metadata, task_id)
    _write_message(self.channel, request)
    _ = _read_message(self.channel)
    return</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.assign_data_to_task"><code class="name flex">
<span>def <span class="ident">assign_data_to_task</span></span>(<span>self, task_id: str, inputs: List[<a title="teaclave.DataMap" href="#teaclave.DataMap">DataMap</a>], outputs: List[<a title="teaclave.DataMap" href="#teaclave.DataMap">DataMap</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_data_to_task(self, task_id: str, inputs: List[DataMap],
                        outputs: List[DataMap]):
    request = AssignDataRequest(self.metadata, task_id, inputs, outputs)
    _write_message(self.channel, request)
    _ = _read_message(self.channel)
    return</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.create_task"><code class="name flex">
<span>def <span class="ident">create_task</span></span>(<span>self, function_id: str, function_arguments: Dict[str, Any], executor: str, inputs_ownership: List[<a title="teaclave.OwnerList" href="#teaclave.OwnerList">OwnerList</a>] = [], outputs_ownership: List[<a title="teaclave.OwnerList" href="#teaclave.OwnerList">OwnerList</a>] = [])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_task(self,
                function_id: str,
                function_arguments: Dict[str, Any],
                executor: str,
                inputs_ownership: List[OwnerList] = [],
                outputs_ownership: List[OwnerList] = []):
    function_arguments = json.dumps(function_arguments)
    request = CreateTaskRequest(self.metadata, function_id,
                                function_arguments, executor,
                                inputs_ownership, outputs_ownership)
    _write_message(self.channel, request)
    response = _read_message(self.channel)
    return response[&#34;content&#34;][&#34;task_id&#34;]</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.get_output_cmac_by_tag"><code class="name flex">
<span>def <span class="ident">get_output_cmac_by_tag</span></span>(<span>self, task_id: str, tag: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_cmac_by_tag(self, task_id: str, tag: str):
    request = GetTaskRequest(self.metadata, task_id)
    while True:
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        time.sleep(1)
        if response[&#34;content&#34;][&#34;status&#34;] == 10:
            break
    return response[&#34;content&#34;][&#34;result&#34;][&#34;result&#34;][&#34;Ok&#34;][&#34;tags_map&#34;][tag]</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.get_task_result"><code class="name flex">
<span>def <span class="ident">get_task_result</span></span>(<span>self, task_id: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_task_result(self, task_id: str):
    request = GetTaskRequest(self.metadata, task_id)

    while True:
        _write_message(self.channel, request)
        response = _read_message(self.channel)
        time.sleep(1)
        if response[&#34;content&#34;][&#34;status&#34;] == 10:
            break

    return response[&#34;content&#34;][&#34;result&#34;][&#34;result&#34;][&#34;Ok&#34;][&#34;return_value&#34;]</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.invoke_task"><code class="name flex">
<span>def <span class="ident">invoke_task</span></span>(<span>self, task_id: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invoke_task(self, task_id: str):
    request = InvokeTaskRequest(self.metadata, task_id)
    _write_message(self.channel, request)
    response = _read_message(self.channel)
    assert (response[&#34;result&#34;] == &#34;ok&#34;)</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.register_function"><code class="name flex">
<span>def <span class="ident">register_function</span></span>(<span>self, name: str, description: str, executor_type: str, public: bool = True, payload: List[int] = [], arguments: List[str] = [], inputs: List[<a title="teaclave.FunctionInput" href="#teaclave.FunctionInput">FunctionInput</a>] = [], outputs: List[<a title="teaclave.FunctionOutput" href="#teaclave.FunctionOutput">FunctionOutput</a>] = [])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_function(self,
                      name: str,
                      description: str,
                      executor_type: str,
                      public: bool = True,
                      payload: List[int] = [],
                      arguments: List[str] = [],
                      inputs: List[FunctionInput] = [],
                      outputs: List[FunctionOutput] = []):
    request = RegisterFunctionRequest(self.metadata, name, description,
                                      executor_type, public, payload,
                                      arguments, inputs, outputs)
    _write_message(self.channel, request)
    response = _read_message(self.channel)
    return response[&#34;content&#34;][&#34;function_id&#34;]</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.register_input_file"><code class="name flex">
<span>def <span class="ident">register_input_file</span></span>(<span>self, url: str, schema: str, key: List[int], iv: List[int], cmac: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_input_file(self, url: str, schema: str, key: List[int],
                        iv: List[int], cmac: str):
    request = RegisterInputFileRequest(self.metadata, url, cmac,
                                       CryptoInfo(schema, key, iv))
    _write_message(self.channel, request)
    response = _read_message(self.channel)
    return response[&#34;content&#34;][&#34;data_id&#34;]</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendClient.register_output_file"><code class="name flex">
<span>def <span class="ident">register_output_file</span></span>(<span>self, url: str, schema: str, key: List[int], iv: List[int])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_output_file(self, url: str, schema: str, key: List[int],
                         iv: List[int]):
    request = RegisterOutputFileRequest(self.metadata, url,
                                        CryptoInfo(schema, key, iv))
    _write_message(self.channel, request)
    response = _read_message(self.channel)
    return response[&#34;content&#34;][&#34;data_id&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="teaclave.FrontendService"><code class="flex name class">
<span>class <span class="ident">FrontendService</span></span>
<span>(</span><span>address: Tuple[str, int], as_root_ca_cert_path: str, enclave_info_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish trusted channel with the frontend service and provide
clients to send request through RPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>The address of the remote services in tuple.</dd>
<dt><strong><code>as_root_ca_cert_path</code></strong></dt>
<dd>Root CA certification of the attestation services
to verify the attestation report.</dd>
<dt><strong><code>enclave_info_path</code></strong></dt>
<dd>Path of enclave info to verify the remote service in
the attestation report.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrontendService:
    &#34;&#34;&#34;Establish trusted channel with the frontend service and provide
    clients to send request through RPC.

    Args:
        address: The address of the remote services in tuple.
        as_root_ca_cert_path: Root CA certification of the attestation services
            to verify the attestation report.
        enclave_info_path: Path of enclave info to verify the remote service in
            the attestation report.
    &#34;&#34;&#34;
    _context = ssl._create_unverified_context()
    _channel = None

    def __init__(self, address: Tuple[str, int], as_root_ca_cert_path: str,
                 enclave_info_path: str):
        self.address = address
        self.as_root_ca_cert_path = as_root_ca_cert_path
        self.enclave_info_path = enclave_info_path

    def connect(self):
        &#34;&#34;&#34;Establish trusted connection and verify remote attestation report.

        Returns:
            FrontendService: The original object which can be chained
                with other methods.
        &#34;&#34;&#34;
        sock = socket.create_connection(self.address)
        channel = self._context.wrap_socket(sock,
                                            server_hostname=self.address[0])
        cert = channel.getpeercert(binary_form=True)
        _verify_report(self.as_root_ca_cert_path, self.enclave_info_path, cert,
                       &#34;frontend&#34;)

        self._channel = channel
        return self

    def get_client(self):
        &#34;&#34;&#34;Get a client of frontend service to send RPC requests.

        Returns:
            FrontendClient: Used for send/receive RPC requests.
        &#34;&#34;&#34;
        return FrontendClient(self._channel)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="teaclave.FrontendService.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish trusted connection and verify remote attestation report.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="teaclave.FrontendService" href="#teaclave.FrontendService">FrontendService</a></code></dt>
<dd>The original object which can be chained
with other methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;Establish trusted connection and verify remote attestation report.

    Returns:
        FrontendService: The original object which can be chained
            with other methods.
    &#34;&#34;&#34;
    sock = socket.create_connection(self.address)
    channel = self._context.wrap_socket(sock,
                                        server_hostname=self.address[0])
    cert = channel.getpeercert(binary_form=True)
    _verify_report(self.as_root_ca_cert_path, self.enclave_info_path, cert,
                   &#34;frontend&#34;)

    self._channel = channel
    return self</code></pre>
</details>
</dd>
<dt id="teaclave.FrontendService.get_client"><code class="name flex">
<span>def <span class="ident">get_client</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a client of frontend service to send RPC requests.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="teaclave.FrontendClient" href="#teaclave.FrontendClient">FrontendClient</a></code></dt>
<dd>Used for send/receive RPC requests.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_client(self):
    &#34;&#34;&#34;Get a client of frontend service to send RPC requests.

    Returns:
        FrontendClient: Used for send/receive RPC requests.
    &#34;&#34;&#34;
    return FrontendClient(self._channel)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="teaclave.FunctionInput"><code class="flex name class">
<span>class <span class="ident">FunctionInput</span></span>
<span>(</span><span>name: str, description: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Function input for registering.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of input data.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Description of the input data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionInput:
    &#34;&#34;&#34;Function input for registering.

    Args:
        name: Name of input data.
        description: Description of the input data.
    &#34;&#34;&#34;
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description</code></pre>
</details>
</dd>
<dt id="teaclave.FunctionOutput"><code class="flex name class">
<span>class <span class="ident">FunctionOutput</span></span>
<span>(</span><span>name: str, description: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Function output for registering.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of output data.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Description of the output data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionOutput:
    &#34;&#34;&#34;Function output for registering.

    Args:
        name: Name of output data.
        description: Description of the output data.
    &#34;&#34;&#34;
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description</code></pre>
</details>
</dd>
<dt id="teaclave.OwnerList"><code class="flex name class">
<span>class <span class="ident">OwnerList</span></span>
<span>(</span><span>data_name: str, uids: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Defines data ownership.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_name</code></strong></dt>
<dd>Name of output data.</dd>
<dt><strong><code>uids</code></strong></dt>
<dd>A list of user id which own this data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OwnerList:
    &#34;&#34;&#34;Defines data ownership.

    Args:
        data_name: Name of output data.
        uids: A list of user id which own this data.
    &#34;&#34;&#34;
    def __init__(self, data_name: str, uids: List[str]):
        self.data_name = data_name
        self.uids = uids</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="teaclave.AuthenticationClient" href="#teaclave.AuthenticationClient">AuthenticationClient</a></code></h4>
<ul class="">
<li><code><a title="teaclave.AuthenticationClient.user_login" href="#teaclave.AuthenticationClient.user_login">user_login</a></code></li>
<li><code><a title="teaclave.AuthenticationClient.user_register" href="#teaclave.AuthenticationClient.user_register">user_register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="teaclave.AuthenticationService" href="#teaclave.AuthenticationService">AuthenticationService</a></code></h4>
<ul class="">
<li><code><a title="teaclave.AuthenticationService.connect" href="#teaclave.AuthenticationService.connect">connect</a></code></li>
<li><code><a title="teaclave.AuthenticationService.get_client" href="#teaclave.AuthenticationService.get_client">get_client</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="teaclave.DataMap" href="#teaclave.DataMap">DataMap</a></code></h4>
</li>
<li>
<h4><code><a title="teaclave.FrontendClient" href="#teaclave.FrontendClient">FrontendClient</a></code></h4>
<ul class="">
<li><code><a title="teaclave.FrontendClient.approve_task" href="#teaclave.FrontendClient.approve_task">approve_task</a></code></li>
<li><code><a title="teaclave.FrontendClient.assign_data_to_task" href="#teaclave.FrontendClient.assign_data_to_task">assign_data_to_task</a></code></li>
<li><code><a title="teaclave.FrontendClient.create_task" href="#teaclave.FrontendClient.create_task">create_task</a></code></li>
<li><code><a title="teaclave.FrontendClient.get_output_cmac_by_tag" href="#teaclave.FrontendClient.get_output_cmac_by_tag">get_output_cmac_by_tag</a></code></li>
<li><code><a title="teaclave.FrontendClient.get_task_result" href="#teaclave.FrontendClient.get_task_result">get_task_result</a></code></li>
<li><code><a title="teaclave.FrontendClient.invoke_task" href="#teaclave.FrontendClient.invoke_task">invoke_task</a></code></li>
<li><code><a title="teaclave.FrontendClient.register_function" href="#teaclave.FrontendClient.register_function">register_function</a></code></li>
<li><code><a title="teaclave.FrontendClient.register_input_file" href="#teaclave.FrontendClient.register_input_file">register_input_file</a></code></li>
<li><code><a title="teaclave.FrontendClient.register_output_file" href="#teaclave.FrontendClient.register_output_file">register_output_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="teaclave.FrontendService" href="#teaclave.FrontendService">FrontendService</a></code></h4>
<ul class="">
<li><code><a title="teaclave.FrontendService.connect" href="#teaclave.FrontendService.connect">connect</a></code></li>
<li><code><a title="teaclave.FrontendService.get_client" href="#teaclave.FrontendService.get_client">get_client</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="teaclave.FunctionInput" href="#teaclave.FunctionInput">FunctionInput</a></code></h4>
</li>
<li>
<h4><code><a title="teaclave.FunctionOutput" href="#teaclave.FunctionOutput">FunctionOutput</a></code></h4>
</li>
<li>
<h4><code><a title="teaclave.OwnerList" href="#teaclave.OwnerList">OwnerList</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>